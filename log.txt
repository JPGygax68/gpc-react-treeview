2015-09-10
==========

I have finally discovered how to manage item selection in my tree view in a way that works with React. Unfortunately, it requires adding a data structure that runs parallel to the component hierarchy used by React, which means that data is represented by (at least) 4 more or less parallel data structures: the one I introduced: node "proxies" (actually this implies a fifth data tree, the one being proxied); the component tree provided to React; the virtual DOM maintained by React; and the real DOM in the browser.

The node proxy hierarchy is needed because component instances in React are not persistent. React generates and re-generates them as it sees fit, using its diff'ing heuristics to update the DOM efficiently. This means that other data objects are needed to work as persistent representatives of the data nodes.

Fortunately, React provides the "ref as callback" feature that makes it possible to create and update a two-way binding between the node proxies and their currently active React component instances.

Note: assigning distinct and immutable keys to each TreeNode component might help minimize the turnover of React component instances. I'll have to gain more experience with React to find out if that is really the case, and whether it's worth further investigation.


2015-09-09
==========

So far, I've described my tree structure using nested React component tags. According to React rules though, that makes the structure immutable.

I need to find out whether or not it is ok to use React components independently from the predefined this.props.children array, more specifically as part of the (parent) React component's *state*.

I see no reason why that should't work. I have to expose a method from TreeView that will give me access to the root node, then expose a TreeNode method that allows me to add child nodes.

Those nodes will not, however, be identical with the TreeNode React component: the former represents the node's content, while the latter is used to display the node and make it interactive.

This leads to a fair bit of code duplication (events raising up from DOM elements to TreeNode React components, from there to node objects, and from there to user code callbacks. Maybe it would be more expedient to remove the TreeNode React component, and replace it with recursively generated DOM elements. However, this would mean that the whole tree view consists of a single React object, which might seriously impair React's ability to optimize the rendering of large constructs.

-----------

I really need to assign keys to my TreeNode components!

2015-09-08
==========

Looking good so far.

Started working on drag & drop. This could prove to be a lot of work to get right. For example, how do I ensure that there will always be a margin between to children of a node, knowing that such a margin is the only way for the user to indicate that he wants to insert an object between two siblings ?

Even worse, how to make this work on a mobile device, where pixel precision with the pointer is just not possible ?