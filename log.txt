2015-09-14
==========

The selected node is now tracked via a reference to the node object itself (which might be a proxy) instead of its component instance, which might change anytime a render occurs.

I'm not sure whether this approach is superior or inferior to the previous one. The new way does not free me from the need to maintain, in each node, a list of child node instances, because those are needed for navigation.

2015-09-11
==========

Interesting thing learned: dragenter and dragleave do not bubble - that much was pretty much a given, but on top of that, moving the pointer over a descendant element will actually generate a dragleave on the previously entered ancestor.

Correction: MDN says dragenter DOES bubble. Hm.

----------

There are several ways to support drag and drop, and I'm still undecided. Perhaps the simplest would be to leave spaces between child nodes, which become visible as insertion marks when dragged over. Advantage: simple; drawback: takes more space than necessary.

Another way is to vertically divide node labels, and to interpret the top zone as "insert before" and the bottom zone as "insert after". This implies that an empty drop space must provided in lieu of children when a node that could have children doesn't have any yet.

Both of the above approaches require precise mouse movement. Another idea would be to provide a vertical "band" to the right of the tree that normally stays invisible, but shows possible insertion points when a drag is in progress. Those insertion markers should look like pointed labels (point to the left), meaning that they could overlap at the end of a level (insert at end of this level, insert before next node of parent level). This could perhaps be solved by temporarily increasing the Z index of a hovered insertion label.

Inserting via drop zones in the label still seems practicable, but special care is needed when a node has (visible) children. In that case, the lower insertion zone should be disregarded. Inserting before the next sibling could then be done on the insertion zone of that sibling, and if there is none, a drop zone should appear. As an alternative, the user could also onto the parent - but that doesn't work at the top level if the root node is hidden.

----------

Ok, it's time to take a look back and then to plan the next moves.

At this point, though I don't have any implementation of drag & drop yet, I have a fairly satisfying starting point, in the sense that I'm confident that I can create a visually and haptically appealing treeview component. A key point is that I feel I will be able to implement insertion by drag and drop, which IMO is the best way for non-programmers to work on the hierarchical structure of web pages (and whole sites). I have implemented a kind of preview based on insertion marks that appear when hovering (of course in a real implementation, they would only appear when a drag operation is in progress).

There are however quite a few details to work out at this point. I'm gonna try to braindump the questions that have popped up in my mind, in no particular order:

- Is it desirable to have a "targetting aid" feature, i.e. to visually highlight every possible drop point whenever any drag operation starts ? It appears that this would be possible, as a component can subscribe to "dragstart" and "dragend" on the document level. I have tested this, and it appears to work. However, there is a possibility that this might lead to intolerable sluggishness when a drag starts, if too many components are doing too many checks and updates [note: checks can imply asynchronous operations in some cases].

- How useful is a "cannot insert here" feedback, seeing as the browser already shows a "stop" sign when hovering over any target that cannot be dropped onto? Perhaps displaying the insertion mark at half opacity is the way to go ?

- What is the "right way" to implement icons? Should this be done via CSS alone, or is there a better way to inject them ? How to create the association between a node type and the icon(s) representing it? How to make it possible for icons to follow the state of the node (typically, open vs closed) ?

- How to properly highlight the label of a node that is willing to accept a drop ?

- How to give the user additional feedback about an imminent drop ?

- How about flyouts, giving the user options about how the dropped data should be interpreted ?

[Unrelated note: selection state is not preserved when closing and reopening a parent node. I believe I should be keeping that state in the NodeProxy objects, and pass it down to the TreeNode elements as properties, NOT state. .... WRONG. Found another way to fix this. Not sure it's the best way though.$
...
Did some research. One blog post states it as clear as can be: "React only gives you the view". So, just as I thought, I'll probably have to implement some module supporting the creation of view models.

Another note: there is a package call react-templates that does not use JSX, but separates the declarative part (the template) and the code into separate files again. Worth a good look.
]

2015-09-10
==========

I have finally discovered how to manage item selection in my tree view in a way that works with React. Unfortunately, it requires adding a data structure that runs parallel to the component hierarchy used by React, which means that data is represented by (at least) 4 more or less parallel data structures: the one I introduced: node "proxies" (actually this implies a fifth data tree, the one being proxied); the component tree provided to React; the virtual DOM maintained by React; and the real DOM in the browser.

The node proxy hierarchy is needed because component instances in React are not persistent. React generates and re-generates them as it sees fit, using its diff'ing heuristics to update the DOM efficiently. This means that other data objects are needed to work as persistent representatives of the data nodes.

Fortunately, React provides the "ref as callback" feature that makes it possible to create and update a two-way binding between the node proxies and their currently active React component instances.

Note: assigning distinct and immutable keys to each TreeNode component might help minimize the turnover of React component instances. I'll have to gain more experience with React to find out if that is really the case, and whether it's worth further investigation.

-----------------

The next challenge will be to come up with a good way to support drag and drop insertion. This could be tricky, because the system should support inserting new nodes anywhere in the visible part of the tree (and, later on, perhaps even in as yet invisible ones by automatically bringing possible "insertion points" into view). The most promising approach is probably to listen to the DragOver event on the UL element, as well as the (newly-introduced) label-box. This will be tricky though, because there are cases when the UL should have priority over the label-box - even though the label-box is further down the hierarchy.

UNLESS - and this is a real possibility - one chooses to visually translate "insertability" by explicitly creating spacing between child nodes (and before and after the first and last). It would even be possible to do this dynamically whenever a drag starts - and even go as far as only creating the insertion spaces where a drop-insertion would actually succeed!

Another idea might be simpler though: alternating child nodes with "insertion markers" that are normally invisible but turn visible when dragged over. These markers could have zero height and use absolutely positioned children to display themselves without interfering with layout.

2015-09-09
==========

So far, I've described my tree structure using nested React component tags. According to React rules though, that makes the structure immutable.

I need to find out whether or not it is ok to use React components independently from the predefined this.props.children array, more specifically as part of the (parent) React component's *state*.

I see no reason why that should't work. I have to expose a method from TreeView that will give me access to the root node, then expose a TreeNode method that allows me to add child nodes.

Those nodes will not, however, be identical with the TreeNode React component: the former represents the node's content, while the latter is used to display the node and make it interactive.

This leads to a fair bit of code duplication (events raising up from DOM elements to TreeNode React components, from there to node objects, and from there to user code callbacks. Maybe it would be more expedient to remove the TreeNode React component, and replace it with recursively generated DOM elements. However, this would mean that the whole tree view consists of a single React object, which might seriously impair React's ability to optimize the rendering of large constructs.

-----------

I really need to assign keys to my TreeNode components!

2015-09-08
==========

Looking good so far.

Started working on drag & drop. This could prove to be a lot of work to get right. For example, how do I ensure that there will always be a margin between to children of a node, knowing that such a margin is the only way for the user to indicate that he wants to insert an object between two siblings ?

Even worse, how to make this work on a mobile device, where pixel precision with the pointer is just not possible ?